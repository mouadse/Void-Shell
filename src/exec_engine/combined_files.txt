
#include "../../include/minishell.h"
#include <stdio.h>
#include <unistd.h>

void	execute_command(t_command *cmd, t_shell_context *context,
		int *exit_status)
{
	if (CMD_EXEC == cmd->type)
	{
		run_exec(cmd, context, exit_status);
	}
	else if (CMD_REDIR == cmd->type)
	{
		execute_redirects_command(cmd, context, exit_status);
	}
	else if (CMD_PIPE == cmd->type)
	{
		execute_pipeline_command(cmd, context, exit_status);
	}
	exit(*exit_status);
}


#include "../../include/minishell.h"
#include <stdio.h>

void	print_exec_error(char *cmd_name, char *error_type)
{
	ft_putstr_fd("Void-shell: ", STDERR_FILENO);
	ft_putstr_fd(cmd_name, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd(error_type, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

static int	file_exists(const char *path)
{
	struct stat	buffer;

	return (stat(path, &buffer) == 0);
}

static int	is_executable(const char *path)
{
	return (access(path, X_OK) == 0);
}

static int	is_builtin_command(t_exec *exec_cmd)
{
	const char	*builtins[] = {"echo", "exit", "env", "export", "unset", "pwd"};
	size_t		i;
	size_t		builtin_count;

	builtin_count = sizeof(builtins) / sizeof(builtins[0]);
	i = 0;
	while (i < builtin_count)
	{
		if (ft_strcmp(exec_cmd->argv[0], builtins[i]) == 0)
			return (1);
		i++;
	}
	return (0);
}

static void	execute_builtin_command(t_exec *exec_cmd, t_shell_context *context,
		int *exit_status)
{
	int	status;
		char cwd[1024];

	if (ft_strcmp(exec_cmd->argv[0], "echo") == 0)
	{
		// Implement echo functionality
		for (int i = 1; exec_cmd->argv[i]; i++)
		{
			printf("%s", exec_cmd->argv[i]);
			if (exec_cmd->argv[i + 1])
				printf(" ");
		}
		printf("\n");
		*exit_status = 0;
	}
	else if (ft_strcmp(exec_cmd->argv[0], "exit") == 0)
	{
		// Implement exit functionality
		status = 0;
		if (exec_cmd->argv[1])
			status = atoi(exec_cmd->argv[1]);
		terminate_cleanly(context, status);
	}
	else if (ft_strcmp(exec_cmd->argv[0], "env") == 0)
	{
		// Implement env functionality
		for (int i = 0; context->envp[i]; i++)
			printf("%s\n", context->envp[i]);
		*exit_status = 0;
	}
	else if (ft_strcmp(exec_cmd->argv[0], "export") == 0)
	{
		// Implement export functionality
		// Placeholder: Just set exit_status to 0
		*exit_status = 0;
	}
	else if (ft_strcmp(exec_cmd->argv[0], "unset") == 0)
	{
		// Implement unset functionality
		// Placeholder: Just set exit_status to 0
		*exit_status = 0;
	}
	else if (ft_strcmp(exec_cmd->argv[0], "pwd") == 0)
	{
		// Implement pwd functionality
		if (getcwd(cwd, sizeof(cwd)) != NULL)
		{
			printf("%s\n", cwd);
			*exit_status = 0;
		}
		else
		{
			print_exec_error(exec_cmd->argv[0],
				"Unable to get current directory");
			*exit_status = 1;
		}
	}
	else
	{
		print_exec_error(exec_cmd->argv[0], "Unknown builtin command");
		*exit_status = 1;
	}
}

static void	execute_external_command(t_command *cmd, t_shell_context *context)
{
	t_exec	*exec_cmd;
	char	*binary_path;

	exec_cmd = (t_exec *)cmd;
	/* Attempt to find the full path of the command */
	binary_path = get_command_path(exec_cmd->argv[0], context->env_vars);
	if (!binary_path)
	{
		/* Command not found in PATH */
		print_exec_error(exec_cmd->argv[0], "command not found");
		terminate_cleanly(context, 127);
	}
	/* Pre-execution checks */
	if (file_exists(binary_path) == -1)
	{
		print_exec_error(exec_cmd->argv[0], "No such file or directory");
		ft_free(binary_path);
		terminate_cleanly(context, 127);
	}
	if (!is_executable(binary_path))
	{
		print_exec_error(exec_cmd->argv[0], "Permission denied");
		ft_free(binary_path);
		terminate_cleanly(context, 127);
	}
	/* Attempt to execute the command */
	handle_execve(binary_path, exec_cmd->argv, context->envp, context);
}

void	run_exec(t_command *cmd, t_shell_context *context, int *exit_status)
{
	t_exec	*exec_cmd;

	exec_cmd = (t_exec *)cmd;
	clean_empty_arguments(exec_cmd);
	handle_executable_path(exec_cmd, context);
	if (is_builtin_command(exec_cmd))
	{
		execute_builtin_command(exec_cmd, context, exit_status);
		// Do not terminate here; allow the shell to continue running
	}
	else
	{
		if (access(exec_cmd->argv[0], X_OK) == 0)
		{
			execve(exec_cmd->argv[0], exec_cmd->argv, context->envp);
			print_exec_error(exec_cmd->argv[0], "Error executing command");
			terminate_cleanly(context, 127);
		}
		else
		{
			execute_external_command(cmd, context);
		}
	}
}


#include "../../include/minishell.h"

void	clean_empty_arguments(t_exec *exec_cmd)
{
	int	i;
	int	j;

	i = 0;
	while (exec_cmd->argv[i])
	{
		if (exec_cmd->argv[i][0] == '\0')
		{
			j = i;
			while (exec_cmd->argv[j])
			{
				exec_cmd->argv[j] = exec_cmd->argv[j + 1];
				j++;
			}
		}
		else
		{
			i++;
		}
	}
}

char	*get_executable_path(char *command, char *path)
{
	int		i;
	char	**path_directories;
	char	*command_with_slash;
	char	*full_path;

	path_directories = ft_split(path, ':');
	command_with_slash = ft_strjoin("/", command);
	i = 0;
	while (path_directories[i])
	{
		full_path = ft_strjoin(path_directories[i], command_with_slash);
		if (access(full_path, X_OK) == 0)
		{
			ft_free(command_with_slash);
			free_array(path_directories);
			return (full_path);
		}
		free(full_path);
		i++;
	}
	ft_free(command_with_slash);
	free_array(path_directories);
	return (NULL);
}

void	handle_invalid_executable(t_exec *cmd, t_shell_context *context,
		struct stat path_stat)
{
	if (S_ISDIR(path_stat.st_mode))
	{
		print_exec_error(cmd->argv[0], "Is a directory");
		terminate_cleanly(context, 127);
	}
	else if (access(cmd->argv[0], X_OK) != 0)
	{
		print_exec_error(cmd->argv[0], "Permission denied");
		terminate_cleanly(context, 127);
	}
}

void	handle_executable_path(t_exec *ecmd, t_shell_context *context)
{
	struct stat	path_stat;

	if (ecmd->argv[0] == NULL)
		terminate_cleanly(context, 127);
	else if (ft_strchr("./", ecmd->argv[0][0]))
	{
		if (stat(ecmd->argv[0], &path_stat) == 0)
			handle_invalid_executable(ecmd, context, path_stat);
		else
		{
			print_exec_error(ecmd->argv[0], "No such file or directory");
			terminate_cleanly(context, 127);
		}
	}
}
char	*get_command_path(char *cmd_name, t_env_var *env_vars)
{
	char	*path_env;
	char	*cmd_path;

	path_env = get_env_value("PATH", env_vars);
	if (!path_env)
		return (NULL);
	cmd_path = get_executable_path(cmd_name, path_env);
	return (cmd_path);
}

void	handle_execve(char *binary_path, char **argv, char **envp,
		t_shell_context *context)
{
	execve(binary_path, argv, envp);
	print_exec_error(argv[0], "Error executing command");
	ft_free(binary_path);
	terminate_cleanly(context, 127);
}


#include "../../include/minishell.h"

static void	save_exit_status(t_shell_context *context, int status_code)
{
	int		fd;
	ssize_t	bytes_written;

	fd = open(SHELL_CHILD_STATUS_FILE, O_WRONLY | O_CREAT | O_APPEND, 0777);
	if (fd < 0)
	{
		perror("open");
		terminate_with_error(context, "Open", EXIT_FAILURE);
	}
	bytes_written = write(fd, &status_code, sizeof(status_code));
	if (bytes_written < 0)
	{
		perror("write");
		terminate_with_error(context, "Write", EXIT_FAILURE);
	}
	close(fd);
}

static void	left_pipe(t_shell_context *context, t_command *cmd, int fd[2],
		int *exit_status)
{
	close(fd[0]);
	dup2(fd[1], STDOUT_FILENO);
	close(fd[1]);
	execute_command(cmd, context, exit_status);
	exit(EXIT_SUCCESS);
}

static void	right_pipe(t_command *cmd, t_shell_context *context, int fd[2],
		int *exit_status)
{
	close(fd[1]);
	dup2(fd[0], STDIN_FILENO);
	close(fd[0]);
	execute_command(cmd, context, exit_status);
	exit(EXIT_SUCCESS);
}

static void	signal_handler(void)
{
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
}

void	execute_pipeline_command(t_command *cmd, t_shell_context *context,
		int *exit_status)
{
	int		fd[2];
	pid_t	pids[2];
	int		status;
	int		heredoc_flag;
	t_pipe	*pipe_cmd;

	heredoc_flag = 0;
	pipe_cmd = (t_pipe *)cmd;
	pipe(fd);
	pids[0] = fork(); // for left command
	if (pids[0] < 0)
	{
		perror("fork");
		exit(EXIT_FAILURE); // to be handled better for potential cleanup
	}
	if (!pids[0])
		left_pipe(context, pipe_cmd->left, fd, exit_status);
	if (pipe_cmd->right->type == CMD_REDIR
		&& ((t_redir *)pipe_cmd->left)->redir_type == '%')
	{
		heredoc_flag = 1;
		close(fd[0]);
		close(fd[1]);
		waitpid(pids[0], NULL, 0);
	}
	pids[1] = fork(); // for right command
	if (pids[1] < 0)
	{
		perror("fork");
		exit(EXIT_FAILURE); // to be handled better for potential cleanup
	}
	if (!pids[1])
		right_pipe(pipe_cmd->right, context, fd, exit_status);
	signal_handler();
	if (!heredoc_flag)
	{
		close(fd[0]);
		close(fd[1]);
		waitpid(pids[0], NULL, 0);
	}
	waitpid(pids[1], &status, 0);
	if (WIFEXITED(status))
		*exit_status = WEXITSTATUS(status);
	else
		*exit_status = 1;
	save_exit_status(context, *exit_status);
	terminate_cleanly(context, *exit_status);
}


#include "../../include/minishell.h"
#include <signal.h>

static char	*getvar_name(char *arg)
{
	int	i;
	int	n;

	i = 0;
	if (ft_isdigit(arg[i]))
	{
		n = arg[i] - '0';
		return (ft_itoa(n));
	}
	while (arg[i] && ((ft_isalnum(arg[i]) || arg[i] == '_')))
		i++;
	return (ft_substr(arg, 0, i));
}

static void	replace_var_in_line(char *line, int *i, t_shell_context *context,
		t_queue_char *q)
{
	char	*var_name;
	char	*var_value;

	(*i)++;
	var_name = getvar_name(line + *i);
	var_value = get_env_value(var_name, context->env_vars);
	if (var_value)
		enqueue_str(q, var_value);
	*i += ft_strlen(var_name);
	if (var_value)
		free(var_value);
}

static char	*process_line(t_shell_context *context, char *line,
		int *exit_status)
{
	int				i;
	t_queue_char	q;
	char			*exit_code;

	i = 0;
	init_queue_char(&q);
	while (line[i])
	{
		if (line[i] == '$' && line[i + 1] == '?')
		{
			exit_code = ft_itoa(*exit_status);
			enqueue_str(&q, exit_code);
			free(exit_code);
			i += 2;
		}
		else if (line[i] == '$' && (is_whitespace(line[i + 1])))
			enqueue_char(&q, line[i++]);
		else if (line[i] == '$')
			replace_var_in_line(line, &i, context, &q);
		else
			enqueue_char(&q, line[i++]);
	}
	if (line)
		free(line);
	return (queue_char_str_convert(&q));
}

static char	*read_heredoc_input(char *del, t_shell_context *context,
		int *exit_status)
{
	char	*line;
	char	*heredoc_line;
	t_queue	queue;
	int		tty_fd;

	tty_fd = open("/dev/tty", O_RDWR);
	if (tty_fd < 0)
		terminate_with_error(context, "open", 1);
	dup2(tty_fd, STDIN_FILENO);
	close(tty_fd);
	init_queue(&queue);
	while (1)
	{
		line = readline("> ");
		if (!line)
		{
			break ;
		}
		if (ft_strlen(line) == ft_strlen(del) + 1 && ft_strncmp(line, del,
				ft_strlen(line) - 1) == 0)
		{
			free(line);
			break ;
		}
		heredoc_line = process_line(context, line, exit_status);
		enqueue(&queue, heredoc_line);
	}
	return (queue_str_convert(&queue));
}

static void	write_heredoc_file(t_shell_context *context, char *content)
{
	int	fd;

	fd = open(SHELL_HEREDOC_FILE, O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd < 0)
		terminate_with_error(context, "open", 1);
	if (write(fd, content, ft_strlen(content)) < 0)
		terminate_with_error(context, "write", 1);
	close(fd);
}

void	execute_redirects_command(t_command *cmd, t_shell_context *context,
		int *exit_status)
{
	t_redir	*redir_cmd;
	char	*heredoc_content;

	redir_cmd = (t_redir *)cmd;
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	if (redir_cmd->redir_type != '%')
	{
		close(redir_cmd->fd);
		if (open(redir_cmd->file, redir_cmd->mode, 0644) < 0)
			terminate_with_error(context, "open", 1);
	}
	else
	{
		heredoc_content = read_heredoc_input(redir_cmd->file, context,
				exit_status);
		write_heredoc_file(context, heredoc_content);
		free(heredoc_content);
		close(redir_cmd->fd);
		if (open("/tmp/herdoc_input.tmp", redir_cmd->mode, 0644) < 0)
			terminate_with_error(context, "open", 1);
	}
	execute_command(redir_cmd->sub_cmd, context, exit_status);
}
